% TODO:
% http://www.usaco.org/index.php?page=viewproblem2&cpid=972
% https://codeforces.com/gym/102979/problem/G
% http://www.usaco.org/index.php?page=viewproblem2&cpid=698
% https://codeforces.com/contest/1146/problem/G
% https://codeforces.com/contest/1107/problem/E
% https://atcoder.jp/contests/arc104/tasks/arc104_f

\chapter{ম্যাট্রিক্স চেইন মাল্টিপ্লিকেশন এবং ইন্টারভাল ডিপি}

অধ্যায়ের টাইটেল দেখে হয়তো আন্দাজ করতে পারছো এই ধরনের ডিপিতে স্টেট হিসেবে একটা
অ্যারের সাব-অ্যারেকে ডিপিতে স্টেট হিসেবে রাখতে হবে। এই ক্যাটাগরির সবচাইতে
ক্লাসিক্যাল উদাহরণ দিয়ে শুরু করা যাক।

\section{একটি ক্লাসিক্যাল সমস্যা}

\begin{example}[ম্যাট্রিক্স চেইন মাল্টিপ্লিকেশন]
  $n (\le 500)$ টা ম্যাট্রিক্স আছে তোমার কাছে, তোমাকে সবচাইতে কম কস্টে তোমাকে
  এদের গুণফল বের করতে হবে। ফরমালি বলতে গেলে, তোমাকে $n$ টা ম্যাট্রিক্স $A_1,
  A_2,
  \ldots A_n$ এর dimension গুলো, অর্থাৎ, $(N_1, M_1), (N_2, M_2), \ldots,
  (N_n, M_n)$ গুলো দেওয়া আছে, যেখানে $A_i$ এর সাইজ হলো $n_i \times m_i$ আর,
  $M_i = N_{i+1} \, (1 \le i < n)$। তোমাকে বের করতে হবে সবচাইতে কম কতটি লুপ
  চালিয়ে তুমি $A_1 A_2 A_3 \dots A_n$ বের করতে পারবা। $a \times b$ এবং $b
  \times c$ সাইজের দুটি ম্যাটিক্স গুন করার কস্ট $abc$।
\end{example}

\begin{solution}
  তুমি যদি ম্যাট্রিক্স এক্সপোনেন্সিয়েশনের চ্যাপ্টারটি পড়ে থাকো তাহলে জানার
  কথা ম্যাট্রিক্স মাল্টিপ্লিকেশন একটি অ্যাসোসিয়েটিভ অপারেশন। যেমন, $(AB)C$ আর
  $A(BC)$ একই জিনিস, অর্থাৎ, $A$ আর $B$ এর গুণফল বের করে সেটাকে $C$ দিয়ে গুন
  দেওয়া যেই কথা, $A$ কে $B$ আর $C$ এর গুণফল দিয়ে গুন দেওয়াও একই কথা। কিন্তু
  এদের গুনের অর্ডারের উপর $ABC$ বের করতে কত টাইম লাগবে তা নির্ভর করে। যেমন
  ধরো, $A$, $B$ আর $C$ এর সাইজ যথাক্রমে $2 \times 1000$, $1000 \times 3$, $3
  \times 4$। যদি $(AB)C$ করি তাহলে কস্ট কত হয় দেখা যাক। প্রথমে $AB$
  করার জন্য কস্ট হলো $2 \times 1000 \times 3$, এবং এরপর $AB$ ম্যাট্রিক্সটির
  সাইজ হবে $2 \times 3$। এখন $(AB)$ এর সাথে $C$ গুন করার কস্ট হলো $2 \times 3
  \times 4$। সুতরাং মোট কস্ট হবে $2 \times 1000 \times 3 + 2 \times 3
  \times 4 = 6024$। কিন্তু $A(BC)$ এর ক্ষেত্রে কস্ট হবে $1000 \times 3 \times
  4 + 2 \times 1000 \times 4 = 20000$!

  একইভাবে ৪টা ম্যাট্রিক্সকে ৫ ভাবে, ৫টা ম্যাট্রিক্সকে ১৪ ভাবে গুন করতে পারবে।
  $n$ টা ম্যাট্রিক্সকে যতভাবে গুন করতে পারা যায় তাকে $C_{n-1}$ দিয়ে লেখা যায়,
  যেখানে $C_n$ হলো $n$-তম Catalan number। আসলে $n$ টা ম্যাট্রিক্স গুন করার
  প্রতিটা উপায়কেই আমরা একটা $n$ লিফের পারফেক্ট বাইনারি ট্রি\footnote{পারফেক্ট
  বাইনারি ট্রিঃ যেই রুটেড ট্রি এর লিফ ছাড়া প্রতিটা নোডের ২টা করে চাইল্ড আছে।
  } দিয়ে প্রকাশ করতে পারি। আর $n$ টা লিফের $C_{n-1}$ টা ভিন্ন ভিন্ন পারফেক্ট
  বাইনারি ট্রি আছে। $n$ তম Catalan number বের করার ফর্মুলা হলো $\frac{1}{n+1}
  \binom{2n}{n}$। চিত্র \ref{perfect_binary_trees_with_5_leaves}-তে ৫টা
  ম্যাট্রিক্স গুন করার সব উপায় দেখানো হয়েছে।
  \begin{figure}
    \centering
    \input{img/matrix-chain/perfect-bin-trees-with-5-leaves/code.tikz}
    \caption{৫টা ম্যাট্রিক্সকে গুন করার সবরকম উপায়}
    \label{perfect_binary_trees_with_5_leaves}
  \end{figure}

  ডায়াগ্রামটা যদি একটু ভালোমত দেখো তাহলে খেয়াল করবা আমরা প্রতিটা উপায় জেনারেট
  করার জন্য প্রথমে $ABCDE$ এর মঝে কোন এক জায়গায় ভাগ করেছি, ধরো $B$ আর $C$ এর
  মাঝে ভাগ করলাম, তারপর $AB$ এবং $CDE$ কে যতভাবে গুন করা যায় তা রিকারসিভলি
  হিসাব করেছি। আর এরপর $(AB)$ কে $(CDE)$ এর সাথে গুণ করার জন্য বিবেচনা করেছি।

  সুতরাং আমাদের ডিপি দেখতে এরকম হবেঃ $\DP \two{l}{r} = $ $A_l A_{l+1} A_{l+2}
  \dots A_{r}$ বের করার মিনিমাম কস্ট। বেস কেইসের জন্য $\DP \two{i}{i} = 0$,
  কারণ একটা ম্যাট্রিক্সের গুণফল বের করতে তো কোন অপারেশনই লাগে না। এখন, $l$
  থেকে $r$ ম্যাট্রিক্স গুলোর গুণফল বের করার জন্য আমরা মাঝখানে কোথাও, ধরি $i$
  আর $i+1$ তম ম্যাট্রিক্সের মাঝে ভাগ করলাম, তাহলে আমরা প্রথমে $A_l \dots A_i$
  আর $A_{i+1} \dots A_{r}$ বের করার অপ্টিমাল কস্ট হিসাব করবো, যেটা আমরা
  পাচ্ছি $\DP\two{l}{i}$ এবং $\DP\two{i+1}{r}$ তে। সাথে $(A_l \dots A_{i})
  \times (A_{i+1} \dots A_{r})$ করার কস্ট হলো $N_l M_i M_r$, কারণ $(A_l \dots
  A_{i})$ ম্যাট্রিক্সের এর সাইজ হবে $N_l \times M_i$ আর $(A_{i+1} \dots A_r)$
  ম্যাট্রিক্সের সাইজ হবে $N_{i+1} \times M_r$। সুতরাং $l < r$ এর ক্ষেত্রে
  ডিপির রিকারেন্স হলোঃ
  \[
    \DP\two{l}{r} = \min_{l \le i < r} \DP\two{l}{i} + \DP\two{i+1}{r} + N_l
    M_i M_r
  \]
  ফাইনাল অ্যান্সার হবে $\DP\two{1}{n}$।
\end{solution}

\begin{example}[\href{https://www.spoj.com/problems/MIXTURES/}{SPOJ -
  Mixtures}]
  হ্যারি পটারের সামনে পাশাপাশি একটা সারিতে $n \, (\le 100)$ টা মিশ্রণ সাজানো
  আছে। প্রত্যেকটা মিশ্রণের ১০০টা রঙের মধ্যে একটা রঙ আছে (০ থেক ৯৯ পর্যন্ত
  নাম্বারিং করা), $i$-তম মিশ্রণের রঙ $a_i \, (0 \le a_i \le 99)$। সে সবগুলা
  মিশ্রণকে একসাথে মিশানোর জন্য $n-1$ বার এই অপারেশনটি করবেঃ
  \begin{itemize}
    \item পাশাপাশি ২টা মিশ্রণ নিয়ে তাদের একসাথে মিশিয়ে ২টার মাঝখানে মিশ্রণটা
    রেখে দিবে, অর্থাৎ, বাকি মিশ্রণ গুলোর ক্রমের কোন পরিবর্তন হবে না। পাশাপাশি
    নির্বাচন করা মিশ্রণগুলোর রঙ যদি $x$ এবং $y$ হয়, তাহলে তাদের মিশ্রণের রঙ
    হবে $(x+y) \mod 100$\footnote{এখানে $a \mod m$ দিয়ে $a$ কে $m$ দিয়ে ভাগ
    করলে যেই ভাগশেষ থাকে তা বুঝানো হচ্ছে।}। আর তাদের মিশ্রিত করার সময় $xy$
    পরিমাণের ধোঁয়া উৎপন্ন হয়।
  \end{itemize}
  তোমাকে বের করতে হবে সবচাইতে কম কতো পরিমাণের ধোঁয়া উৎপন্ন করে মিশ্রণ গুলোকে
  হ্যারি মিশ্রিত করতে পারবে।
\end{example}

\begin{solution}
  আগের প্রবলেমের মতই এই প্রবলেমেও $n$টা মিশ্রণকে মিক্স করার যেকোনো উপায়কেই
  তুমি একটা $n$ লিফের পারফেক্ট বাইনারি ট্রি হিসেবে আঁকতে পারবা।
  $\DP\two{l}{r}$ হলো $l$ থেকে $r$ এর মধ্যে মিশ্রণ গুলোকে যদি অপ্টিমালি
  মিশানো হয়, তাহলে সর্বনিম্ন কি পরিমাণের ধোঁয়া উৎপন্ন হবে। এখন তুমি মাঝখানে
  কোথায় ভাঙ্গবে তার উপর ইটারেট করবা। ধরো, $i$ আর $i+1$ এর মাঝে ভাঙ্গেছো,
  তাহলে ২ পাশের কস্ট হলো $\DP\two{l}{i}$ আর $\DP\two{i+1}{r}$। $l \ldots i$
  এর মিশ্রণগুলোকে মিক্স করে যেই মিশ্রণ পাবো তার রঙ হবে $\left(\sum_{j=l}^{i}
  a_j \right) \mod 100$ (কারণ, $(((x+y)\mod m) + z) \mod m = (x+y+z) \mod
  m$)। একইভাবে $i+1 \ldots r$ এর মিশ্রণগুলোকে মিক্স করার পর $\left(
  \sum_{j=i+1}^{r} a_j \right) \mod 100$ রঙের মিশ্রণ পাবা। এদের মিক্স করলে
  আবার $\left( \left(\sum_{j=l}^{i} a_j \right) \mod 100 \right) \times
  \left( \left( \sum_{j=i+1}^{r} a_j \right) \mod 100 \right)$ পরিমাণের ধোঁয়া
  উৎপন্ন হবে। তাহলে রিকারেন্সটা হলোঃ
  \[
    \DP\two{l}{r} = \min_{i=l}^{r-1} \DP\two{l}{i} + \DP\two{i+1}{r} + L
    \times R
  \]
  যেখানে, $L = \left(\sum_{j=l}^{i} a_j \right) \mod 100$, $R = \left(
  \sum_{j=i+1}^{r} a_j \right) \mod 100$, এবং $\DP\two{i}{i} = 0$।
\end{solution}

\begin{example}[\href{http://www.usaco.org/index.php?page=viewproblem2&%
  cpid=972}{USACO - Greedy Pie Eaters}]
  ফার্মার জনের কাছে $M$টা গরু আর $N$ টা পাই আছে। গরুগুলো $1$ থেকে $M$ এবং
  পাইগুলো $1$ থেকে $N$ পর্যন্ত নাম্বারিং করা। $i$-তম গরু $[l_i, r_i]$ রেঞ্জের
  মধ্যে পাইগুলো খেতে পছন্দ করে। তোমাকে আরেকটা জিনিস বলে দেওয়া আছে, তা হলো ২টা
  গরুর পছন্দের রেঞ্জ একই হবে না কখনো। $i$-তম গরুর ওজন হলো $w_i$।

  \noindent ফার্মার জন একটা সিকুয়েন্স $c_1, c_2, \ldots, c_K$ বাছাই করবে,
  যেটা দিয়ে গরুগুলো কি অর্ডারে পাই খেতে আসবে তা বুঝাবে, অর্থাৎ, প্রথমে
  $c_1$-তম গরুটি আসবে, এরপর $c_2$-তম গরুটি আসবে...। একটা গরু আসলে সে তার
  পছন্দের রেঞ্জে বাকি থাকা সব পাই খেয়ে ফেলবে। কিন্তু যদি তার পছন্দের রেঞ্জে
  কোন পাইই বাকি না থাকে তাহলে সে মন খারাপ করে বসবে! ফার্মার জন এমন একটা
  সিকুয়েন্স বাছাই করতে চায় যাতে $(w_{c_1} + w_{c_2} + \ldots + w_{c_K})$ এর
  মান ম্যাক্সিমাইজ হয়, এবং বাছাই করা $K$ টা গরুর মধ্যে কেও মন খারাপ না করে।
  $1 \le N \le 300, 1 \le M \le \frac{N(N+1)}{2}, 1 \le w_i \le 10^6$।
\end{example}

\begin{example}[\href{https://codeforces.com/contest/1146/problem/%
  G}{Codeforces 1146G - Zoning Restrictions}]
  তুমি $n$ টা বিল্ডিং বানাবে, এবং বিল্ডিং বানানোর স্পটগুলো $1$ থেকে $n$
  পর্যন্ত নাম্বারিং করা। প্রতিটা বিল্ডিঙের উচ্চতা 0 থেকে $h$ এর মধ্যে যেকোনো
  একটি পর্ণসংখ্যা হতে পারে। কোন স্পটে যদি $a$ উচ্চতার বিল্ডিং বানাও তাহলে
  তুমি $a^2$ টাকা পাবা। তুমি যাতে ইচ্ছা মতো উচ্চতার বিল্ডিং নির্মাণ করতে না
  পারো তাই $m$ টা শর্ত দেওয়া আছে -- $i$ তম শর্তে তোমাকে বলা আছে $l_i$ থেকে
  $r_i$ স্পটের বিল্ডিং গুলোর উচ্চতা সর্বোচ্চ $x_i$ হতে পারবে। যদি এদের মধ্যে
  কোনটার উচ্চতা $x_i$ এর বেশি হয় তাহলে তোমাকে $c_i$ টাকা পেনাল্টি দিতে হবে।
  খেয়াল করো, $l_i$ থেকে $r_i$ এর মধ্যে একাধিক বিল্ডিং-এর উচ্চতা $x_i$ এর
  চাইতে বেশি হলেও কিন্তু $i$-তম শর্ত ভঙ্গের জন্য একবারই $c_i$ টাকা পেনাল্টি
  দিবে। অপ্টিমালভাবে বিল্ডিং-এর উচ্চতা নির্বাচন করে ম্যাক্সিমাম কতো প্রফিট
  পেতে পারো তা হিসাব করো। $1 \le n, m, h \le 50, 1 \le l_i \le r_i \le n, 0
  \le x_i \le h, 1 \le c_i \le 5\,000$।
\end{example}

\begin{example}[\href{http://www.usaco.org/index.php?page=viewproblem2%
  &cpid=698}{USACO - Subsequence Reversal}]
  তোমাকে একটা অ্যারে $a_1, a_2, \ldots, a_N$ দেওয়া আছে। প্রথমে এই অ্যারের
  একটি সাবসিকুয়েন্স নির্বাচন করে তা রিভার্স করবা, এবং এরপর যেই অ্যারেটা পাবা
  তার Longest Non-decreasing সাবসিকুয়েন্স বের করবা। তোমার উদ্দেশ্য হচ্ছে, যেই
  সাবসিকুয়েন্সটা রিভার্স করবা, সেটা এমনভাবে নির্বাচন করা, যাতে Longest
  Non-decreasing সাবসিকুয়েন্স সর্বোচ্চ হয়। যেমন, নিচের অ্যারেটির গাড় করা
  সাবসিকুয়েন্স নির্বাচন করে সেটি রিভার্স করলে পুরো অ্যারেটিই Non-decreasing
  হয়ে যায়। $1 \le N, a_i \le 50$।
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
      \hline
      1 & 2 & 3 & \cellcolor{black!25}9 & 5 & 6 & \cellcolor{black!25}8 &
      \cellcolor{black!25}7 & \cellcolor{black!25}4 \\
      \hline
    \end{tabular}\\
    $\downarrow$\\
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
      \hline
      1 & 2 & 3 & \cellcolor{black!25}4 & 5 & 6 & \cellcolor{black!25}7 &
      \cellcolor{black!25}8 & \cellcolor{black!25}9 \\
      \hline
    \end{tabular}
  \end{center}
\end{example}

\begin{example}[\href{https://codeforces.com/contest/1107/problem/E}%
  {Codeforces 1107E - Vasya and Binary String}]
  তোমার কাছে $n$ লেংথের একটি বাইনারি স্ট্রিং $s$, এবং $n$ সাইজের একটি অ্যারে
  $a$ আছে। স্ট্রিংটা খালি না হয়ে যাওয়া পর্যন্ত তুমি এই অপারেশনটি অ্যাপ্লাই
  করবাঃ $s$ এর মধ্যে একটা কন্সেকিউটিভ সাবস্ট্রিং বাছাই করবা যাতে সেই
  সাবস্ট্রিং এর সব ক্যারেক্টার একই হয়, এবং সেই সাবস্ট্রিংটা ডিলিট করে এরপর ২
  পাশের বাকি থাকা সাবস্ট্রিংগুলো (এগুলোর কোনটা ফাকা হলে সমস্যা নেই) জোড়া
  লাগিয়ে দিবা। যেমন 1\colorbox{black!25}{111}101 $\rightarrow$ 1101। $x$
  লেংথের সাবস্ট্রিং ডিলিট করলে $a_x$ পয়েন্ট পাবে। ম্যাক্সিমাম কতো পয়েন্ট
  পেতে পারো তুমি? $1 \le n \le 100, 1 \le a_i \le 10^9$।
\end{example}

\begin{example}[\href{https://atcoder.jp/contests/arc104/tasks/arc104_f}%
  {AtCoder - Visibility Sequence}]
  আগের বিল্ডিং বানানোর ঠিকাদারিতে তুমি ব্যাপক পরিমাণের লাভ করেছ (ডাইনামিক
  প্প্রোগ্রামিংকে ধন্যবাদ না দিলেই নয়), তাই তুমি আবারো পরিকল্পনা করেছ $N$ টা
  বিল্ডিং বানাবে। এইবারের শর্তগুলো হলো, প্রতিটা $i \, (1 \le i \le N)$ এর
  জন্য তোমাকে একটা $X_i$ দেয়াও আছে, যার মানে হলো $i$ তম বিল্ডিংয়ের উচ্চতা 1
  থেকে $X_i$ এর মধ্যে যেকোনো একটি পুর্ণসংখ্যা হতে পারবে। ধরো তুমি $i$ তম
  বিল্ডিং বানিয়েছ $H_i$ উচ্চতার। এখন প্রতি $i \, (1 \le i \le N)$ এর জন্য
  আমরা $P_i$ কে এভাবে ডিফাইন করবোঃ যদি এমন কোন পর্ণসংখ্যা $j \, (1 \le j <
  i)$ থাকে যাতে $H_j > H_i$ হয়, তাহলে $P_i$ হবে এমন ম্যাক্সিমাম $j$, আর নাহলে
  $P_i = -1$। এবার $H$ সিকুয়েন্সটির সবরকম কম্বিনেশনের কথা চিন্তা করো, তারা
  প্রত্যেকেই একটি করে $P$ জেনারেট করবে। দুটি ভিন্ন $H$ এর জন্য তাদের জেনারেট
  করা $P$ একই হয়ে যেতে পারে আবার ভিন্নও হতে পারে। তোমাকে বের করতে হবে, কয়টা
  ভিন্ন ভিন্ন $P$ জেনারেট হবে। $1 \le N \le 100, 1 \le X_i \le 10^5$।
\end{example}

\begin{example}[\href{https://codeforces.com/gym/102979/problem/G}%
  {XXI Open Cup, GP of Suwon - Generate The Array}]
  ধরো তোমাকে একটা $N$ লেংথের অ্যারে $A$ দেওয়া আছে, এবং তুমি এতে কিছু কুয়েরি
  করবাঃ অ্যারের একটা সেগমেন্ট $[i, j]$ এর জন্য সেই সেগমেন্টের ম্যাক্সিমাম বের
  করবা। $[i, j]$ সেগমেন্টটি $Q_{i, j}$ বার করা হবে।\\
  কিন্তু অ্যারেটা তোমাকে দেওয়া নাই, তুমি বানাবে সেটা। $1$ থেকে $N$ এর মধ্যে
  প্রতিটা $i$ এর জন্য $A_i$ এর মান হিসেবে তুমি $K_i$ টা আলাদা আলাদা মান
  $V_{i,1}, V_{i,2}, \ldots, V_{i, K_i}$ থেকে একটি বাছাই করতে পারবা। $A_i$ এর
  জন্য $V_{i, j}$ বাছাই করার কস্ট হলো $C_{i, j}$।\\
  সবগুলো কুয়েরির শেষে তোমার স্কোর হবেঃ (সব ইন্টারভাল কুয়েরির রেজাল্টের যোগফল)
  $-$ ($A_i$ ভ্যালু গুলা বাছাই করার কস্টের যোগফল)। ম্যাক্সিমাম কতো স্কোর পেতে
  পারো তা বের করো।
\end{example}