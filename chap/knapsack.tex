\chapter{ন্যাপস্যাক}
\section{0/1 ন্যাপস্যাক}
ধর তোমার কাছে \(n\) টি বস্তু আছে, \(i\) তম বস্তুর ওজন \(w_{i}\) এবং দাম \(v_{i}\)। তোমার কাছে একটা ব্যাগ (ন্যাপস্যাক) আছে যা সর্বোচ্চ \(W\) ওজনের বস্তু ধারণ করতে পারে। এই ব্যাগে তুমি সর্বোচ্চ কত দামের বস্তু রাখতে পারবে?

একে 0/1 ন্যাপস্যাক বলা হয়, কারণ এখানে প্রতিটি বস্তু সর্বোচ্চ একবারই নেওয়া যাবে। এটির জন্য আমাদের ডাইনামিক প্রোগ্রামিং এর সাহায্য নিতে হবে। ধরি \(f_{i, j} = \) প্রথম \(i\) টি বস্তুর মধ্যে সর্বোচ্চ কত দামের বস্তু নেওয়া যায় যাতে বস্তুগুলোর ওজনের যোগফল \(\leq j\) হয়। তাহলে আমাদের রিকারেন্সটি
\[f_{i, j} = \max \lbrace f_{i - 1, j}, \, f_{i - 1, j - w_{i}} + v_{i} \rbrace\]

অর্থাৎ \(f_{n, W}\) এর মানই হবে আমাদের অ্যান্সার। এখানে টাইম ও মেমরি কমপ্লেক্সিটি উভয়ই \(\mathcal{O}(nW)\)।
তবে যেহেতু \(f_{i, j}\) এর মান কেবলমাত্র \(f_{i - 1, 0} \, , \, f_{i - 1, 1} \, , \, f_{i - 1, 2} \, , \dots, \, f_{i - 1, W}\) এর ওপর নির্ভর করে তাই \(\mathcal{O}(W)\) মেমরি দিয়েও কাজটি করা সম্ভব। (মেমোরি অপটিমাইজেশনের চ্যাপ্টারটা দেখ) 

\section{0-K ন্যাপস্যাক}
ধর তোমার কাছে \(n\) টাইপের বস্তু আছে, \(i\) তম টাইপের বস্তু আছে \(k_{i}\) টি এবং এদের প্রত্যেকটির ওজন \(w_{i}\) এবং দাম \(v_{i}\)। তোমার কাছে একটা ব্যাগ (ন্যাপস্যাক) আছে যা সর্বোচ্চ \(W\) ওজনের বস্তু ধারণ করতে পারে। এই ব্যাগে তুমি সর্বোচ্চ কত দামের বস্তু রাখতে পারবে?

আগেরটার সাথে এটার পার্থক্য হচ্ছে এখানে \(i\) তম বস্তু সর্বোচ্চ \(k_{i}\) সংখ্যক বার নেওয়া যাবে। এখানেও আগের মতই ডাইনামিক প্রোগ্রামিং ব্যবহার করা যায়, ধরি \(f_{i, j} = \) প্রথম \(i\) টি বস্তুর মধ্যে সর্বোচ্চ কত দামের বস্তু নেওয়া যায় যাতে বস্তুগুলোর ওজনের যোগফল \(\leq j\) হয়। তাহলে, 
\[f_{i, j} = \max_{m = 0}^{k_{i}} \lbrace f_{i - 1, j - w_{i}m} + v_{i}m \rbrace\]

অর্থাৎ \(i\) তম বস্তু কতবার নিচ্ছি সেটার সবগুলো অপশন কনসিডার করতে হবে। আগেরটার কোড বুঝে থাকলে এটার কোড নিজেরই পারার কথা। এখানে টাইম কমপ্লেক্সিটি হবে \(\mathcal{O}(W \times \sum k_{i})\) 

কিন্তু এইখানে সমস্যা হচ্ছে \(\sum k_{i}\) এর মান অনেক বড় হতে পারে। আশার কথা হল এই প্রবলেমের এইটাই সবচেয়ে অপটিমাল সলিউশন না। \(\mathcal{O}(W \times \sum \log k_{i})\) কমপ্লেক্সিটিতেও এই প্রবলেমটি সল্ভ করা সম্ভব।

আইডিয়াটি হচ্ছে প্রত্যেক \(k_{i}\) এর বাইনারি রিপ্রেজেন্টেশনকে ব্যবহার করা। একটি উদাহরণ দেখা যাক, ধর কোন এক টাইপের বস্তুর \((k_{i}, w_{i}, v_{i}) = (27, 13, 5)\)।  অর্থাৎ ঐ টাইপের বস্তু আছে \(27\) টি এবং তার ওজন \(13\) ও দাম \(5\)। এখন \(27\) কে এইভাবে লেখা যায়: \[27 = 11011_{2} = 1111_{2} + 1100_{2} = (2^{4} + 2^{3} + 2^{2} + 2^{1} + 2^{0}) + 12\]

অর্থাৎ আমরা যদি \((27, 13, 5)\) বস্তুটির বদলে \((1, 13 \times 2^{4}, 5 \times 2^{4}), \ (1, 13 \times 2^{3}, 5 \times 2^{3}), \ (1, 13 \times 2^{2}, 5 \times 2^{2}), \ (1, 13 \times 2^{1}, 5 \times 2^{1}), \ (1, 13 \times 2^{0}, 5 \times 2^{0})\) এবং \((1, 13 \times 12, 5 \times 12)\) বস্তুগুলোর ওপর ন্যাপস্যাক ডিপি চালাই তাহলে উত্তর চেঞ্জ হবে না, এর কারন হচ্ছে \(2^{4}, \ 2^{3}, \ 2^{2}, \ 2^{1}, \ 2^{0}\) এবং \(12\) দিয়ে  \(0\) থেকে \(27\) পর্যন্ত সব সংখ্যা কে লেখা যায়, তবে $27$ এর বড় কোন সংখ্যাকে লেখা যায় না (কিছু কিছু সংখ্যাকে একাধিক উপায়ে লেখা যেতে পারে, কিন্তু সেটা আমাদের জন্য সমস্যা না)। এইভাবে প্রতিটি বস্তুকে তার বাইনারি রিপ্রেজেন্টেশন অনুযায়ী ভেঙ্গে দিতে হবে। ভেঙ্গে দেওয়ার পর কিন্তু আমাদের আর 0-K ন্যাপস্যাক থাকছে না, 0-1 ন্যাপস্যাক হয়ে যাচ্ছে। কারণ ভেঙ্গে দেওয়ার পর প্রত্যেক বস্তুকে সর্বোচ্চ একবারই নেওয়া সম্ভব (\(k_{i} = 1)\)।  অর্থাৎ ভেঙ্গে দেওয়ার পর আমাদের মোট বস্তু হবে \(\mathcal{O}(\sum \log k_{i})\) টি। তাই 0-1 ন্যাপস্যাক এর কমপ্লেক্সিটি হবে \(\mathcal{O}(W \times \sum \log k_{i})\)। 

মজার ব্যাপার হল এই প্রবলেমের \(\mathcal{O}(W \times \sum \log k_{i})\) এর চেয়েও ভাল সলিউশন আছে। \(\mathcal{O}(nW)\) কমপ্লেক্সিটিতেও 0-K ন্যাপস্যাক সল্ভ করা সম্ভব। রিকারেন্সটি আবার লক্ষ্য করি: \\
\[f_{i, j} = \max_{m = 0}^{k_{i}} \lbrace f_{i - 1, j - w_{i}m} + v_{i}m \rbrace \ \ \ (1)\]

কোনো ফিক্সড \(i\) এর জন্য \(f_{i, 0} \, , \, f_{i, 1} \, , \dots, \, f_{i, W}\) এর মান যদি আমরা \(\mathcal{O}(W)\) তে বের করতে পারি, তাহলেই \(\mathcal{O}(nW)\) কমপ্লেক্সিটি হয়ে যাবে। এখন লক্ষ্য করি, \(f_{i, j}\) এর মান \(f_{i - 1, j} \, , \, f_{i - 1, j - w_{i}} \, , \, f_{i - 1, j - 2w_{i}} \, , \, f_{i - 1, 3w_{i}} \, , \dots\) মানগুলোর ওপর নির্ভর করে। অন্যভাবে বলা যায় \(f_{i, j}\) এর মান এমন সব \(f_{i - 1, p}\) এর মানের ওপর নির্ভর করে যাতে \(p \equiv j \mod w_{i}\) হয়।  এটাকে কাজে লাগিয়েই \(\mathcal{O}(W)\) তে কাজটি করা সম্ভব। আমরা \(f_{i, j}\) এর মান \(0 \leq j \leq W\) এর জন্য একসাথে বের না করে \(w_{i}\) এর প্রত্যেক মডুলো ক্লাসের জন্য আলাদা ভাবে বের করতে পারি।  বুঝানোর  সুবিধার্তে ধরি, 
\[g_{m}(i, j) = f_{i, m + jw_{i}}\]
 
যেখানে \(0 \leq m < w_{i}\)। এখন আমরা একটা ফিক্সড \(m\) এর জন্য \(g_{m}(i, j)\) এর সকল মান বের করব, যেখানে \(0 \leq m + jw_{i} \leq W\)।  \((1)\) নং রিকারেন্সের সাহায্যে \(g_{m}(i, j)\) কে এইভাবে লেখা যায়: 

\begin{align*}
g_m(i, j) & = \max_{h = j - k_{i}}^{j} \lbrace g_{m}(i - 1, h) + (j - h)v_{i} \rbrace \\ 
          & = \max_{h = j - k_{i}}^{j} \lbrace g_{m}(i - 1, h) - hv_{i} \rbrace + jv_{i} 
\end{align*}

এখান থেকেই বুঝা যাচ্ছে \(g_{m}(i - 1, 0), g_{m}(i - 1, 1) - v_{i}, g_{m}(i - 1, 2) - 2v_{i}, \dots\) এর প্রতিটি \(k_{i} + 1\) দৈর্ঘ্যের সাবঅ্যারের মিনিমাম ভ্যালু বের করতে পারলেই  \(g_{m}(i, j)\) এর সকল মান আমরা সহজেই বের করতে পারব। কোনো \(n\) দৈর্ঘ্যের অ্যারের প্রতিটি \(m\) দৈর্ঘ্যের সাবঅ্যারের মিনিমাম (বা ম্যাক্সিমাম) ভ্যালু \(\mathcal{O}(n)\) এই বের করা যায় (স্লাইডিং উইন্ডোর সাহায্যে)। অর্থাৎ প্রত্যেক মডুলো ক্লাসের জন্য আমরা লিনিয়ার টাইমেই \(g_{m}\) এর মান বের করতে পারব। যেহেতু প্রত্যেকটি সংখ্যাই কেবলমাত্র একটি মডুলো ক্লাসের অন্তর্ভুক্ত তাই ওভারঅল কমপ্লক্সিটি হবে \(\mathcal{O}(W)\)। তাই প্রত্যেকটি \(i\) এর জন্য \(f_{i, j}\) এর মান বের করতে \(\mathcal{O}(nW)\) কমপ্লেক্সিটি প্রয়োজন।   

\section{সাবসেট সাম:} 
এই সেকশনের সব জায়গায় সেট বলতে মাল্টিসেট বুঝান হবে। অর্থাৎ সেটে একই উপাদান একাধিক বার থাকতে পারে। 

ন্যাপস্যাকের সবচেয়ে গুরুত্বপূর্ণ ভ্যারিয়েশন এটি। ধর তোমার কাছে \(n\) দৈর্ঘ্যের একটা অ্যারে \(a\) এবং একটি নাম্বার \(m\) দেওয়া আছে। তোমাকে বলতে হবে \(a\) এর নাম্বার গুলো ব্যবহার করে যোগফল \(m\) বানানো যায় কিনা।  

অর্থাৎ \(S = \lbrace 1, 2, 3, \dots, n \rbrace\) হলে এমন কোন সাবসেট \(T\) পাওয়া সম্ভব কিনা যাতে \(T \subseteq S\) এবং \(\sum_{i \in T} a_{i} = m\) হয়। 

ধরি, 
 
\[f_{i, j} = \begin{cases}
  1, & \text{যদি প্রথম } i \text{ টি সংখ্যা হতে যোগফল } j \text{ বানানো সম্ভব হয়}, \\
  0, & \text{সম্ভব না হয়}.
\end{cases}\]

তাহলে, 
\[f_{i, j} = f_{i - 1, j} \lor f_{i - 1, j - a_{i}}\] \\

\(\lor\) এখানে or অপারেটরটাকে বুঝাচ্ছে।  তাহলে এই ডিপিটা ক্যালকুলেট করতে আমাদের \(\mathcal{O}(nm)\) টাইম ও \(\mathcal{O}(m)\) মেমরি লাগছে। তবে এই সলিউশন কে অপটিমাইজ করার জন্য আরেকটা সস্তা অপটিমাইজেশন আছে। তা হল \texttt{bitset} ব্যবহার করা।  \texttt{bitset} ব্যবহার করলে টাইম কমপ্লেক্সিটি দাড়ায় \(\mathcal{O}(\frac{nm}{64})\) এবং মেমোরি কমপ্লেক্সিটি দাড়ায় \(\mathcal{O}(\frac{m}{64})\)। 

\section{ডাইনামিক সাবসেট সাম:}
ধর সাবসেট সাম প্রবলেমটায় তোমাকে কিছু আপডেট আর কুয়েরিও দেওয়া হল। অর্থাৎ প্রত্যেক আপডেটে তোমাকে একটি সংখ্যা \(p\) দেওয়া হবে এবং তোমাকে সংখ্যাটাকে সেটে  অ্যাড করতে হবে অথবা সেট থেকে রিমুভ করতে হবে। প্রত্যেক কুয়েরিতে তোমাকে একটি সংখ্যা \(r\) দেওয়া হবে এবং তোমাকে বলতে হবে \(r\) সংখ্যাটিকে সেটের সংখ্যাগুলোর যোগফল হিসেবে লেখা যায় কিনা। 

ধরা যাক মোট আপডেট ও কুয়েরি \(Q\) টি। তাহলে যদি আমরা \(Q\) বারই সাবসেট সাম-এর ডিপি টা নতুন করে আপডেট করি তাহলে কমপ্লেক্সিটি \(\mathcal{O}(\frac{Qnr_{\max}}{64})\) হয়ে যাচ্ছে। তবে এই প্রবলেমটি \(\mathcal{O}(Qr_{\max})\) টাইমেও করা সম্ভব, যেখানে \(r_{\max}\) হল \(r\) এর ম্যাক্সিমাম ভ্যালু।     

এর জন্য আমাদের ডিপি টাকে একটু চেঞ্জ করতে হবে। ধরি, \(f_j = \) সেটে যেসব উপাদান আছে তাদের কোনো সাবসেট নিয়ে কতভাবে \(j\) সংখ্যাটি বানানো যায়। তাহলে প্রত্যেক কুয়েরিতে \(f_r > 0\) কিনা তা চেক করলেই হচ্ছে আমাদের।  আর যদি নতুন কোন নাম্বার অ্যাড বা রিমুভ করতে হয় তাহলে নরমাল সাবসেট সাম ডিপির মতই \(f_j\) এর মান আপডেট করা যায়। এখন সমস্যা হচ্ছে \(f_j\) মান অনেক বড় হয়ে যেতে পারে, এমনকি \texttt{long long} এও আটবে না। তাই \(f_r\) কে আমরা \(\mod P\) ক্যালকুলেট করব যেখানে \(P\) র‍্যানডম কোন প্রাইম নাম্বার। এখন যদি \(f_r = 0\) হয়, এবং তারপরেও \(r\) কে যোগফল হিসেবে লেখা যাবে সেটির সম্ভাবনা নেয় বললেই চলে। (কেউ চাইলে ২-৩ টি \texttt{mod} ও ব্যবহার করতে পারে)।

\section{\(\mathcal{O} \left ( s \sqrt{s} \right )\) সাবসেট সাম:} 
এখানে \(s\) সেটের সবগুলো সংখ্যার যোগফল বুঝাচ্ছে।  যদি কোন সংখ্যা \(t\) এর থেকে বড় হয়, তাহলে আমরা নরমালি \texttt{bitset} দিয়ে ডিপি টা আপডেট করব, এটি করতে \(\mathcal{O} \left ( \frac{s}{64} \times \frac{s}{t} \right )\) কমপ্লেক্সিটি লাগে (কারন \(t\) এর থেকে বড় সংখ্যা সর্বোচ্চ \(\frac{s}{t}\) বার পাওয়া যাবে)। আর যদি \(t\) এর থেকে ছোট হয় তাহলে আমরা 0-k ন্যাপস্যাক এর মত ডিপি টাকে আপডেট করব। অর্থাৎ \(t\) এর থেকে ছোট কোন সংখ্যা কতবার আছে সেটা বের করে তার ওপর 0-k ন্যাপস্যাক প্রয়োগ করব। এ কাজটি করতে সর্বোচ্চ \(\mathcal{O}(st)\) কমপ্লেক্সিটি লাগে।  \(t = \sqrt{\frac{s}{64}}\) হলে টোটাল কমপ্লেক্সিটি দাড়ায়: 
\[\mathcal{O} \left ( \frac{s}{64} \times \frac{s}{t} + s \times t \right ) = \mathcal{O} \left ( s \sqrt{ \frac{s}{64} } \right )\]


