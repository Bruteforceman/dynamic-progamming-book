\chapter{এক্সচেঞ্জ আর্গুমেন্ট}

\section{প্রমাণ দাও}

সাধারণত গ্রিডি অ্যালগরিদম গুলো অনেকটা এরকম হয়ঃ যতক্ষণ পর্যন্ত সম্ভব প্রদত্ত শর্তগুলো ঠিক রেখে তুমি প্রতিবার একটি করে ইলিমেন্ট সিলেক্ট করে তোমার সলিউশনে অ্যাড করবা যেটায় তোমার সবচেয়ে বেশি লাভ হয়। আমরা এক্সচেঞ্জ আর্গুমেন্ট ব্যবহার করে যেমন আমাদের এই গ্রিডি অ্যালগরিদমের শুদ্ধতা প্রমাণ করতে পারি, তেমনি এক্সচেঞ্জ আর্গুমেন্ট এর ধাপ গুলো নিয়ে চিন্তা করতে গিয়ে আমাদের গ্রিডি সলিউশনও দাঁড় করিয়ে ফেলতে পারি। এক্সচেঞ্জ আর্গুমেন্ট প্রুফ গুলোর মেইন আইডিয়া হলো, তুমি যেকোনো একটি অপ্টিমাল সলিউশন নিবে, তারপর সেটিকে ধাপে ধাপে এমনভাবে তোমার গ্রিডি সলিউশনে পরিবর্তন করবে যেন প্রতি ধাপে তোমার কোন লস না হয়। তাহলে তুমি বলতে পারবে তোমার গ্রিডি সলিউশন অন্তত কোন একটি অপ্টিমাল সলিউশনের চাইতে খারাপ না। অন্যভাবে বলতে গেলে, তোমার সলিউশনও একটি অপ্টিমাল সলিউশন। একটা উদাহরণ দেখা যাক।

\begin{problem}[ডট প্রডাক্ট মিনিমাইজেশন]
তোমাকে দুটি অ্যারে দেওয়া আছে। তোমাকে এমনভাবে অ্যারে দুটিকে রিঅ্যারেঞ্জ করতে হবে যেন তাদের ডট গুণফল অর্থাৎ, $\sum_{i=1}^{N} A_i B_i$ এর মান মিনিমাম হয়।
\end{problem}
\begin{solution}
আমরা চাই না দুটি বড় বড় সংখ্যা একসাথে থাকুক কারণ তাদের গুণফল অবশ্যই বড় হয়ে যাবে। অন্যদিকে, দুটি ছোট ছোট সংখ্যা একসাথে থাকলে লাভ হতে পারে বলে মনে হতে পারে। কিন্তু এরকম করলে বড় বড় সংখ্যা গুলো একসাথে হয়ে যাবে। তাহলে এরকম একটা কিছু করা যায়- একটি ছোট আর একটি বড় সংখ্যা একসাথে পেয়ারআপ করা। এই আইডিয়াটাকে গুছিয়ে বললে হবে- প্রথম অ্যারেটিকে নন-ডিক্রিজিং অর্ডারে সর্ট করা এবং দ্বিতীয় অ্যারেটিকে নন-ইনক্রিজিং অর্ডারে সর্ট করা। এখন আমাদের প্রমাণ করতে হবে, এটি একটি অপ্টিমাল সলিউশন। আমরা ধরে নিতে পারি প্রথম অ্যারেটি নন-ডিক্রিজিং অর্ডারে সর্ট করা আছে। এখন ধরো এমন একটা অপ্টিমাল সলিউশন আছে যেখানে $B$ ডিক্রিজিং অর্ডারে সর্ট করা নেই, অর্থাৎ, এমন একটা $i$ আছে যেন, $B_{i} < B_{i+1}$।  এখন আমরা এদেরকে সোয়াপ করে আমাদের গ্রিডি সলিউশনের দিকে যেতে চাই। যদি সোয়াপ করি, তাহলে আমদের গুণফলে যেই অতিরিক্ত কস্ট অ্যাড হবে তা হলোঃ $A_iB_{i+1} + A_{i+1}B_i - A_iB_i - A_{i+1}B_{i+1}$।  সুতরাং আমাদের প্রমাণ করতে হবে-
\begin{align*}
	A_iB_{i+1} + A_{i+1}B_i - A_iB_i - A_{i+1}B_{i+1} &\le 0 & \\
	A_i(B_{i+1} - B_i) - A_{i+1}(B_{i+1} - B_i) &\le 0\\
	A_i &\le A_{i+1} &\text{কারণ, $B_{i+1} - B_i > 0$}
\end{align*}
আসলেই তাই! (ইমপ্লিকেশন গুলো উল্টা অর্ডারে লিখতে হবে আরকি ফর্মাল প্রুফে...) তাহলে আমরা প্রুফ করে ফেললাম- এভাবে সোয়াপ করতে থাকলে আমরা কোন লস ছাড়াই অপ্টিমাল সলিউশন থেকে গ্রিডি সলিউশনে পৌছাতে পারবো (খেয়াল করো, শুধুমাত্র দুটো পাশাপাশি উপাদান সোয়াপ করে করেই কিন্তু একটি সিকুয়েন্সের যেকোনো পারমুটেশনে পৌছনো যায়)। অর্থাৎ, আমাদের গ্রিডি সলিউশনও একটি অপ্টিমাল সলিউশন!
\end{solution}

\section{মুল টেকনিক}

গ্রিডি অ্যালগরিদম বের করার পরে তা এক্সচেঞ্জ আর্গুমেন্ট দিয়ে প্রমাণ করার জন্য আমরা যা করি তাকে মূলত নিচের ৩টা স্টেপে ভাগ করা যায়-
\begin{enumerate}
	\item ধরলাম আমাদের গ্রিডি অ্যালগরিদম ব্যবহার করে আমরা একটা সলিউশন $G = \cbra{g_1, g_2, \ldots, g_n}$ পেয়েছি, আর $O = \cbra{o_1, o_2, \ldots, o_m}$ একটি অপ্টিমাল সলিউশন।  এখানে কিন্তু আমরা ধরে নিচ্ছি $G$ আর $O$ দুটোই সবরকমের শর্ত মেনেই বানানো হয়েছে।
	\item ধরে নাও $G \not= O$ আর  তাদের মধ্যে পার্থক্য করো, যেমন, ধর $G$ তে এমন একটি উপাদান পেলে যেটি $O$ তে নেই (অথবা, $O$ তে এমন একটি উপাদান পেলে যেটি $G$ তে নেই) অথবা এমন দুটি উপাদান আছে যারা $G$ তে যেই অর্ডারে আছে, $O$ তে তার বিপরীত অর্ডারে আছে।
	\item \textbf{এক্সচেঞ্জ।} যেমন, প্রথম কেইস এর জন্য $O$ থেকে একটি উপাদান বের করে আরেকটি উপাদান ঢুকালা, অথবা দ্বিতীয় কেইস এর জন্য অর্ডারটা সোয়াপ করে দিলে (বেশিরভাগ সময় খালি পাশাপাশি ২টা উপাদান নিয়েই কাজ করা হয়)। এখন কারণ দেখাও, এক্সচেঞ্জ করার পর তোমার নতুন সলিউশনটা আগেরটার তুলোনায় খারাপ না এবং এরপর দেখাবে তুমি যদি এইরকম এক্সচেঞ্জ করতে থাকো তাহলে একসময় $O$ কে $G$ এর সমান বানাতে পারবে। সুতরাং তোমার গ্রিডি সলিউশন যেকোনো অপ্টিমাল সলিউশনের (বা যেকোনো নন-অপ্টিমাল সলিউশনের) চাইতে ভাল বা সমান, যার মানে দাঁড়ালো তোমার সলিউশনও একটি অপ্টিমাল সলিউশন।
\end{enumerate}

অনেক ভারী ভারী আলোচনা হয়ে গেলো! আসলে প্রথমেই যে বলেছিলাম এক্সচেঞ্জ আর্গুমেন্ট দিয়ে প্রুফ করতে গিয়ে আমরা অনেকসময় গ্রিডি সলিউশনও দাঁড় করিয়ে ফেলতে পারি- এভাবে চিন্তা করলে আমরা কিছু কন্ডিশন পাই (যেমন পাশাপাশি ২টা উপাদানের মধ্যে কিরকম সম্পর্ক হতে পারে) এবং সেগুলো থেকে আমরা উপাদান গুলোর একটি অর্ডারিং পেতে পারি যেটা আমাদের কাজকে অনেক সহজ করে দেয়। আশা করি পরের অংশের উদাহরণগুলো দেখলে বিষয়টা পরিষ্কার হবে।

\begin{diybox}
	দুটি অ্যারে দেওয়া আছে (একই উপাদান বার বার থাকতে পারে)। অ্যারে দুটির উপাদানের মাল্টিসেট গুলো সমান, অর্থাৎ, এদেরকে সর্ট করলে অ্যারে দুটি একই হবে। তুমি প্রতি ধাপে প্রথম অ্যারেটির দুটি পাশাপাশি উপাদান সোয়াপ করতে পারবা। মিনিমাম কয়টি মুভে প্রথম অ্যারেটিকে তুমি দ্বিতীয় অ্যারের সমান করতে পারবে তা বের করতে হবে।
\end{diybox}


\section{ডিপির সাথে সম্পর্ক}

\begin{problem}
তোমাকে দুটি $N$ সাইজের বাইনারি অ্যারে $A$ আর $B$ দেওয়া আছে। তুমি প্রতি ধাপে নিচের যেকোনো একটি অপারেশন $A$ অ্যারের উপর প্রয়োগ করতে পারবা-
\begin{enumerate}
	\item \textbf{সেট অপারেশনঃ} একটি রেঞ্জ $[l, r]$ যেখানে $1 \le l \le r \le N$ বাছাই করে $A[l \ldots r]$ এর সব মান $0$ করে দিবে।
	\item \textbf{রিসেট অপারেশনঃ} একটি রেঞ্জ $[l, r]$ যেখানে $1 \le l \le r \le N$ বাছাই করে $A[l \ldots r]$ এর সব মান $1$ করে দিবে।
	\item \textbf{ফ্লিপ অপারেশনঃ} একটি রেঞ্জ $[l, r]$ যেখানে $1 \le l \le r \le N$ বাছাই করে $A[l \ldots r]$ এর সব মান পরিবর্তন করে দিবে (০ থাকলে ১ আর ১ থাকলে ০ করতে হবে)।
\end{enumerate}
তোমাকে বের করতে হবে মিনিমাম কয়টি অপারেশনে তুমি $A$ অ্যারেকে $B$ এর সমান করতে পারবে।
\end{problem}
\begin{solution}
যদিও বেশিরভাগ অপটিমাইজেশন প্রবলেমই হয় গ্রিডি না হয় ডিপি হয়, তাও কেও যদি এইধরনের প্রবলেম আগে কখনো না দেখে থাকে তাহলে এটা যে আদৌ ডিপি প্রবলেম, তা আন্দাজ করারও উপায় আছে বলে আমি মনে করি না। প্রবলেমটা সম্পর্কে কিছু আইডিয়া পাওয়ার জন্য আমরা একটি মিনিমাম অপারেশনের সিকুয়েন্স কেমন হতে পারে তা চিন্তা করতে পারি। ধরো এমন একটা সিকুয়েন্স হলো $o_1, o_2, \ldots, o_k$ (তাহলে $k$ হলো আমাদের উত্তর, আর, একটা অপারেশনকে আমরা একটা টুপল $o_i = (l_i, r_i, \star_i)$ দিয়ে বর্ণনা করবো)।  এখন আমরা একটু খতিয়ে দেখবো, একটা অপারেশনের ওপর আরেকটা অপারেশনের প্রভাব কি হতে পারে। ২টা অপারেশন $o_i$ আর $o_j$ নাও ($i < j$)। এখন দেখো, যদি $j > i+1$ হয় তাহলে ঐ ২টি অপারেশনের মাঝে আরও অনেক অপারেশন এসে যাচ্ছে, যেগুলো আমাদের চিন্তাকে জটিল করে ফেলছে। তাই, আমরা আপাতত $j=i+1$ ধরি অর্থাৎ $o_i$ আর $o_{i+1}$ নিয়ে চিন্তা করবো এখন। আমরা এবার এই অপারেশন দুটো কোনোভাবে কম্বাইন করে একটি অপারেশন বানানোর চেষ্টা করবো যাতে আমাদের অপারেশনের সংখ্যা কমে যায়। কিন্তু আমরা তো একটা মিনিমাম সাইজের সিকুয়েন্স নিয়েছিলাম! হ্যাঁ, আমরা যদি ঐ ২টা অপারেশন কম্বাইন করতে পারি, তাহলে এমন বৈশিষ্ট্যের ২টি অপারেশন আমরা কোন অপ্টিমাল সিকুয়েন্সে  পাশাপাশি পাবো না। এভাবে আমরা কিরকম বৈশিষ্ট্য একটি অপ্টিমাল সিকুয়েন্সে থাকবে আর কিরকম বৈশিষ্ট্য থাকবে না তা সম্পর্কে ধারনা পেতে পারি। কয়েকটা কেইস আছে-
\begin{itemize}
  \item[$\bullet$] $\star_i = \oplus, \star_{i+1} = \oplus$\footnote{$\oplus$ দিয়ে টগল, $1$ দিয়ে সেট এবং $0$ দিয়ে রিসেট অপারেশন বুঝানো হয়েছে}। প্রথমেই সবচেয়ে সহজটা দেখা যাক। দুটি রেঞ্জের জন্য সবরকমের অপশন এঁকে দেখতে পারো, যেমন- এমটা রেঞ্জের ভিতর আরেকটা অথবা একটার ভিতর আরেকটা সম্পূর্ণ না থেকে ওভারল্যাপ করছে ইত্যাদি। যদি রেঞ্জ দুটি একে-অপরকে  ছেদই না করে তাহলে তো আমাদের আর তেমন কিছু করার নেই। কিন্তু সবকিছু সাজিয়ে রাখার জন্য আমরা যেটা করতে পারি তা হলো- যদি $l_i > l_{i+1}$ হয় তাহলে তাদের সোয়াপ করে দিতে পারি। আমরা এখন থেকে যখনই পারি, $l$ এর এরকম Non-decreasing অর্ডার ঠিক রাখার চেষ্টা করবো।
  \item[$\bullet$] $\star_i = \oplus, \star_{i+1} = 1$।  রেঞ্জগুলো যদি ওভারল্যাপ না করে তাহলে আগের মতই তেমন কিছু করতে হবে না। কিন্তু আমাদের সুবিধার জন্য আমরা সেট অপারেশনটাকে আগে নিয়ে আসতে পারি আর টগল অপারেশনটাকে পরে নিয়ে যেতে পারি। খেয়াল করো, আমাদের এই ট্রান্সফর্মেশনের পরেও কিন্তু ফাইনাল অ্যারে একই থাকছে। আর টগল অপারেশনটাকে পরে নেওয়ার কারণ হলো সেট বা রিসেট অপারেশনের চাইতে টগল অপারেশনে আমরা এক দিক দিয়ে বেশি অপশন পাই। এখন, রেঞ্জগুলো যদি ওভারল্যাপ করে তাহলে কি হবে? চিন্তা করে দেখো, আমরা কিন্তু প্রথমে $o_i$ এর রেঞ্জে রিসেট অপারেশন অ্যাপ্লাই করে তারপর $[l_i, r_i] \cup [l_{i+1}, r_{i+1}]$ রেঞ্জে টগল অপারেশন অ্যাপ্লাই করতে পারি; ফাইনাল অ্যারে একই থাকবে।
  \item[$\bullet$] $\star_i = \oplus, \star_{i+1} = 0$। আগের কেইসের মত এখানেও প্রথম অপারেশনটিকে সেট এবং পরের অপারেশনটিকে টগল বানানো যায়।
  \item[$\bullet$] বাকি কেইস গুলাতে আসলে সব রেঞ্জগুলো আলাদা আলাদা (disjoint) করে ফেলা যায়। এরপর না হয় আগে সেট অপারেশন এবং পরে রিসেট অপারেশন- এইরকম অর্ডার ঠিক রাখলাম।
\end{itemize}
উপরের কেইসগুলোতে প্রথমে সেট বা রিসেট অপারেশন রেখে এবং পরে টগল অপারেশন রেখে বিবেচনা করা হয়নি কারণ আমরা এমনিতেই চাচ্ছি টগল অপারেশনকে পরে পাঠাতে।\\
উপরের ঘাঁটাঘাঁটি থেকে আমরা এই অবজারভেশন পাই- অন্তত একটি এমন অপ্টিমাল সলিউশন আছে যেটাতে সব সেট অপারেশন আগে, তারপর সব রিসেট অপারেশন এবং শেষে সব টগল অপারেশন থাকবে। যদিও আমাদের কাছে কোনো গ্রিডি সলিউশন বা তেমন কিছু জানা ছিল না, তারপরও আমরা সেই এক্সচেঞ্জ আর্গুমেন্ট এর ধাপ গুলোই প্রয়োগ করার চেষ্টা করেই এমন গুরুত্বপূর্ণ অবজারভেশন পেয়ে গেলাম। এখন আমাদের বাকি এই অবজারভেশনের সাথে ইন্টারভাল ডিপি এবং বিটমাস্ক ডিপির সমন্বয় করে একটা ডিপি সলিউশন দাঁড় করানো। এখানে একটি খেয়াল করার বিষয় হলো, আমরা এই অবজারভেশন বের করতে দিয়ে আরও কিছু অপ্রয়োজনীয় কাজ করেছি, যেমন- প্রথম কেইসে $l$ দ্বারা অর্ডারিং করা। আসলে আমরা অনেকসময়ই এরকম করে থাকি (যেমন আমাদের একটি অ্যারে দেওয়া থাকলে আর অ্যারের উপাদানগুলো যদি যেকোনো ক্রমে নিয়ে কাজ করা যায় তাহলে আমরা ধরে নেই অ্যারেটা সর্টেড আছে) কারণ সবকিছু সাজানো গুছানো থাকলে চিন্তা করতে সুবিধা হয়। এটা একটা সাধারণ প্রবলেম সল্ভিং স্ট্রেটেজি।

\end{solution}
