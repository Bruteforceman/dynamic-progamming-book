\chapter{ব্যারিকেডস ট্রিক}

\section{একটি পোলিশ সমস্যা}
বাইটল্যান্ড নামের একটি দ্বীপে \(n\) টি শহর আছে এবং শহরগুলোর মধ্যে কিছু দ্বিমুখী রাস্তা আছে। এ শহরের ম্যাপ একটি বিশেষ ধরনের, একটি শহর থেকে আরেকটি শহরে কেবলমাত্র একভাবেই যাওয়া যায়। অর্থাৎ গ্রাফ থিওরির ভাষায় বাইটল্যান্ডের মাপটি একটি ট্রি গ্রাফ। 

দুঃখজনকভাবে বাইটল্যান্ড দ্বীপটিতে এখন যুদ্ধ চলছে। বাইটল্যান্ডের সেনাবাহিনী  নিজেদের প্রতিরক্ষার জন্য একটি যুদ্ধক্ষেত্র তৈরি করতে চায়। তারা যুদ্ধক্ষেত্রটি তৈরি করার জন্য কিছু রাস্তা ব্লক করে দিবে। যুদ্ধক্ষেত্রটি তৈরির জন্য তাদের তিনটি শর্ত মেনে চলতে হবে।

\renewcommand{\labelitemi}{$\rightarrow$}
\begin{itemize}
 \item যুদ্ধক্ষেত্রের অন্তর্গত শহরগুলোর নিজেদের মধ্যে চলাচলের রাস্তা থাকবে। অর্থাৎ যুদ্ধক্ষেত্রের যেকোনো দুটি শহরের মধ্যে কোনো ব্লক করা রাস্তা থাকবে না। 
 \item যুদ্ধক্ষেত্রের ভিতরের কোনো শহর থেকে যুদ্ধক্ষেত্রের বাইরের কোনো শহরে যাওয়ার কোনো রাস্তা থাকবে না। 
 \item যুদ্ধক্ষেত্রের মধ্যে \(k\) টি শহর থাকবে। 
\end{itemize}

বেশি সংখ্যক রাস্তা ব্লক করে দিলে শহরের মধ্যে যাতায়াতে সমস্যা হতে হতে পারে। তোমাকে বাইটল্যান্ড দ্বীপটির যুদ্ধক্ষেত্র প্রস্তুত করার দায়িত্ব দেওয়া হয়েছে। তোমাকে বলতে হবে সর্বনিম্ন কয়টি রাস্তা ব্লক করে বাইটল্যান্ড শহরে একটি যুদ্ধক্ষেত্র প্রস্তুত করা সম্ভব। 

এটি আসলে পোল্যান্ডের ইনফরমাটিক্স অলিম্পিয়াডের ব্যারিকেডস নামের প্রবলেম। এই প্রবলেম থেকেই মূলত এই অধ্যায়ের আইডিয়াটা জনপ্রিয় হয়েছিল, তাই এখন এই ট্রিক এখন ব্যারিকেডস ট্রিক নামেই প্রোগ্রামিং মহলে অধিক পরিচিত। 

\section{সমাধান}
সমস্যাটি দেখে অনেকেই আন্দাজ করতে পারছ এইখানে ট্রি গ্রাফটির ওপরেই ডাইনামিক প্রোগ্রামিং করতে হবে। এ ধরনের সমস্যা সমাধানের জন্য একটি বিশেষ ধরনের ডাইনামিক প্রোগ্রামিং ব্যবহার করা হয় যাকে সিবলিং ডিপি নামে অনেকে চিনে। প্রথমে দেখা যাক আমাদের ডিপি স্টেট কি হতে পারে।

প্রথমে আমরা যেকোনো একটি নোডকে ট্রি-এর রুট ধরে নিব। ধরা যাক ১ নম্বর নোডটিকে আমরা রুট হিসেবে ধরেছি। \(v\) নোডটির সাবট্রিকে আমরা \(T_{v}\) দ্বারা প্রকাশ করব এবং সাবট্রি-এর মধ্যে নোড সংখ্যাকে \(|T_{v}|\) দ্বারা প্রকাশ করব। অর্থাৎ \(T_{1}\) দিয়ে সম্পূর্ণ ট্রি টাকেই বুঝানো হচ্ছে। যারা ট্রি ডিপির সাথে মোটামুটি পরিচিত তারা ইতোমধ্যে বুঝে গিয়েছ আমাদের স্টেট কি হতে পারে। ধরা যাক \(f_{v, x}\) এর মান হল সর্বনিম্ন কতটি এজ মুছে দিলে \(v\) এর সাবট্রি-এর মধ্যে \(x\) টি নোডের একটি কানেক্টেড সাবগ্রাফ পাওয়া যাবে যাতে \(v\) নোডটি নিজেও সেই সাবগ্রাফের অংশ হয়। আমরা যদি প্রতিটি নোড \(v\) জন্য \(f_{v, x}\) এর মানগুলো বের করে নিতে পারি তাহলে খুব সহজেই প্রতিটি কুয়েরি \(\mathcal{O}(n)\) কমপ্লেক্সিটিতে বের করে ফেলতে পারব।

এখন দেখা যাক কিভাবে আমরা \(f_{v, x}\) এর মানগুলো ক্যালকুলেট করতে পারি। ধরা যাক নোড \(v\) এর জন্য আমরা \(f_{v, x}\) এর মান বের করছি। \(v\) এর সাবট্রিতে \(|T_{v}| - 1\) টি এজ আছে, তাই \(|T_{v}| - 1\)  টির বেশি এজ মুছে ফেলা সম্ভব না, এজন্য \(1 \leq x < |T_{v}|\) এর জন্য \(f_{v, x}\) এর মান বের করাই আমাদের জন্য যথেষ্ট। ধর নোড \(v\) এর চাইল্ডগুলো হল \(u_{1}, u_{2}, \dots , u_{m}\)। প্রতিটি চাইল্ডের জন্য যদি আমাদের \(f_{u_{i}, *}\) এর মানগুলো ক্যালকুলেট করা থাকে তাহলে \(f_{v, x}\) এর মান আমরা কিভাবে বের করতে পারি সেটি একটু চিন্তা করে দেখ।  

যেকোনো একটি চাইল্ড \(u_{i}\) এর কথা চিন্তা কর। আমাদের হাতে দুটি অপশন আছে: হয় আমরা \(u_{i}\) এর সাবট্রি থেকে আমরা \(q_{i}\) টি নোডের এমন একটি সাবগ্রাফ নিব যাতে \(u_{i}\) নোডটিও তার অন্তর্ভুক্ত থাকে, অথবা \(\left (v, u_{i} \right )\) এজটিই আমরা মুছে দিব; সেক্ষেত্রে আমরা \(q_{i} = 0\) ধরতে পারি। প্রথম ক্ষেত্রে আমাদের \(f_{u_{i}, q_{i}}\) টি এজ মুছে ফেলতে হবে, আর দ্বিতীয় ক্ষেত্রে আমাদের ১ টি এজ মুছে ফেলতে হবে। আর আমাদের \(f_{v, x}\) এর মান বের করার জন্য এমন ভাবে \(q_{i}\) সিলেক্ট করতে হবে যেন \(q_{1} + q_{2} + \dots + q_{m} = x - 1\) হয়।

ডিপি স্টেট-এ শুধুমাত্র \(v\) আর \(x\) এর মান রেখে আমরা আর আগাতে পারছি না, কারন আমরা যদি প্রতিটি চাইল্ড থেকে সম্ভাব্য সকল ধরনের \(q_{i}\) এর মান নিয়ে চেক করি তাহলে আমাদের কমপ্লেক্সিটি এক্সপোনেনশিয়াল হয়ে যাবে। তাই আমাদের \(f_{v, x}\) এর মান বের করার জন্য আরেকটি ডিপির সাহায্য নিতে হবে। 

ধরি \(g_{i, x}\) এর মান হল \(v\) এর প্রথম \(i\) টি চাইল্ড থেকে সর্বনিম্ন যে কয়টি এজ মুছে দিলে \(x\) টি নোডের একটি সাবগ্রাফ পাওয়া যাবে যেন \(v\) নোডটিও সেই সাবগ্রাফের অংশ হয়। অর্থাৎ প্রথম \(i\) টি চাইল্ড থেকে \(q_{1}, q_{2}, \dots , q_{i}\) এমনভাবে সিলেক্ট করতে হবে যেন \(q_{1} + q_{2} + \dots + q_{i} = x - 1\) হয়। এখন \(g_{i, x}\) এর মান আমরা \(g_{i - 1, *}\) মানগুলো থেকে খুব সহজেই বের করে নিতে পারি নিচের রিকারেন্সটির মাধ্যমে:

\[g_{i, x} = \min \lbrace g_{i - 1, x} + 1, \min_{1 \leq a \leq x} g_{i - 1, x - a} + f_{u_{i}, a} \rbrace\]
% \[g(i, x) = \min \lbrace g(i - 1, x), \min_{1 \leq a \leq x} g(i - 1, x - a) + f(u_{i}, a) \rbrace\]

উপরের লাইনে দুটি অপশনই বিবেচনা করা হয়েছে। যদি \(i\) তম চাইল্ডের সাথে \(v\) এর এজটি মুছে ফেলা হয় তাহলে \(i\) তম চাইল্ডের আগের চাইল্ডগুলো থেকে \(x\) টি নোডের সাবগ্রাফ পেতে কমপক্ষে \(g_{i - 1, x}\) টি এজ মুছে ফেলতে হবে এবং \(\left ( v, u_{i}\right ) \) এজটি সহ মোট \(g_{i - 1, x} + 1\) টি এজ মুছতে হবে। আর যদি \(i\) তম চাইল্ড \(u_{i}\) এর সাবট্রি থেকে \(a\) টি নোডের সাবগ্রাফ নেওয়া হয় যাতে \(u_{i}\) তাতে অন্তর্ভুক্ত থাকে তাহলে \(u_{i}\) এর সাবট্রি থেকে কমপক্ষে \(f_{u_{i}, a}\) টি এজ মুছে ফেলতে হবে এবং \(u_{1}, u_{2}, \dots , u_{i - 1}\) চাইল্ডগুলো থেকে মোট \(g_{i - 1, x - a}\) টি এজ মুছে ফেলতে হবে। অর্থাৎ মোট \(g_{i - 1, x - a} + f_{u_{i}, a}\) টি এজ মুছে ফেলতে হবে। সবশেষে \(g_{m, x}\) এর যে মান ক্যালকুলেট করা হবে সেটিই হবে \(f_{v, x}\) এর মান। এভাবে প্রতিটি নোডের জন্য আমরা আরেকটি ডিপির মাধ্যমে \(f_{v, x}\) এর মানগুলো নির্নয় করতে পারব। 

\section{কমপ্লেক্সিটি অ্যানালাইসিস}
নির্দিষ্ট কোনো একটি নোড \(v\) এর জন্য \(f_{v, *}\) এর মানগুলো বের করতে কয়টি অপারেশন লাগবে সেটি হিসেব করার চেষ্টা করব আমরা। প্রথমত কোনো নোড \(v\) এর সাবট্রিতে \(|T_{v}| - 1\) সংখ্যক এজ আছে, সুতরাং \(x = 1, 2, 3, \dots , (|T_{v}| - 1)\) এর জন্য \(f_{v, x}\) এর মানগুলো বের করলেই হবে আমাদের। আবার \(g_{i - 1, *}\) থেকে \(g_{i, *}\) এর মানগুলো বের করতে আমাদের \(\mathcal{O} \left (|T_{v}| . |T_{u_{i}}| \right )\) কমপ্লেক্সিটি প্রয়োজন। সুতরাং নোড \(v\) এর জন্য \(f_{v, *}\) এর মানগুলো বের করতে আমাদের সর্বমোট কমপ্লেক্সিটি \(\mathcal{O} \left (|T_{v}| \times \sum_{i = 1}^{m} |T_{u_{i}}| \right )\)। যেহেতু \(|T_{v}| = 1 + \sum_{i = 1}^{m} |T_{u_{i}}|\) তাই আমরা একে লেখতে পারি: \(\mathcal{O} \left (|T_{v}| . |T_{v}| \right ) = \mathcal{O} \left (|T_{v}|^{2} \right ) \) হিসেবে। আর সব নোডের জন্য এই মান যোগ করলে আমাদের কমপ্লেক্সিটি হবে \(\mathcal{O} \left ( \sum_{i = 1}^{n} |T_{i}|^{2} \right ) = \mathcal{O} \left ( n^{3} \right ) \)

মজার ব্যাপার হল আমরা আমাদের অ্যালগোরিদমকে তেমন কোনো পরিবর্তন না করেই \(\mathcal{O} (n^{2})\) বানিয়ে দিতে পারি। এজন্য আমাদের একটু ভিন্নভাবে অ্যানালাইসিস করতে হবে।

\begin{lemma} 
\(T_{v}\) এর সকল নোডের জন্য \(f_{*, *}\) এর মানগুলো \(\mathcal{O} \left ( |T_{v}|^{2} \right )\) কমপ্লেক্সিটিতে বের করা সম্ভব। 
\end{lemma}

\textbf{প্রমাণ:}
প্রমাণের জন্য গানিতিক আরোহের সাহায্য নিব। এখানে আমরা \(|T_{v}|\) এর ওপর গাণিতিক আরোহ প্রয়োগ করব। ধর, যদি কোন নোড \(h\) এর জন্য \(|T_{h}| < |T_{v}|\) হয় তাহলে \(T_{h}\) এর সকল নোডের জন্য \(f_{*, *}\) এর মানগুলো \(\mathcal{O}(|T_{h}|^{2})\) কমপ্লেক্সিটিতে বের করা সম্ভব।  আমরা প্রমাণ করব তাহলে \(T_{v}\) এর সকল নোডের জন্যও \(f_{*, *}\) এর মানগুলো \(\mathcal{O}(|T_{v}|^{2})\) কমপ্লেক্সিটিতে বের করা সম্ভব। বেস কেস \(|T_{v}| = 1\) এর জন্য নিঃসন্দেহে \(\mathcal{O} (1^{2}) = \mathcal{O} (1)\) কমপ্লেক্সিটিতে \(f_{*, *}\) এর মানগুলো বের করা সম্ভব।  

ধর \(v\) এর চাইল্ডগুলো হল \(u_{1}, u_{2}, \dots, u_{m}\)। যেহেতু \(|T_{u_{i}}| < |T_{v}|\) তাই \(u_{1}, u_{2}, \dots, u_{m}\) চাইল্ডগুলোর সাবট্রির সকল নোডের জন্য \(f_{*, *}\) এর মানগুলো বের করতে আমাদের যথাক্রমে $\mathcal{O}(|T_{u_{1}}|^{2})$, $\mathcal{O}(|T_{u_{2}}|^{2})$, $\dots$, $\mathcal{O}(|T_{u_{m}}|^{2})$ কমপ্লেক্সিটি প্রয়োজন। সুতরাং চাইল্ডগুলোর সাবট্রির সকল নোডের জন্য \(f_{*, *}\) এর মানগুলো বের করতে \(\mathcal{O} \left ( \sum_{i = 1}^{m} |T_{u_{i}}|^{2} \right )\) কমপ্লেক্সিটি লাগবে। 

এখন আমাদের শুধুমাত্র \(f_{v, *}\) এর মানগুলো বের করা বাকি। লক্ষ্য কর, \(v\) এর প্রথম \(i\) টি চাইল্ড থেকে সর্বোচ্চ \(\sum_{j = 1}^{i} |T_{u_{j}}|\) টি এজ মুছে ফেলা সম্ভব। তাই \(g_{i, x}\) এর মান বের করার সময় আমাদের \(x\) এর মান সর্বোচ্চ \(\sum_{j = 1}^{i} |T_{u_{j}}|\) পর্যন্ত বিবেচনা করলেই হচ্ছে। \(g_{i, x}\) এর রিকারেন্সটি আবার লক্ষ্য কর:

\[g_{i, x} = \min \lbrace g_{i - 1, x} + 1, \min_{1 \leq a \leq x} g_{i - 1, x - a} + f_{u_{i}, a} \rbrace\]

এখানে \(x - a\) এর মান সর্বোচ্চ \(\sum_{j = 1}^{i - 1} |T_{u_{j}}|\) হবে এবং \(a\) এর মান সর্বোচ্চ \(|T_{u_{i}}|\) হবে। তাই \(g_{i, *}\) এর মান বের করতে আমাদের আসলে \(\mathcal{O} \left( |T_{u_{i}}| \times \sum_{j = 1}^{i - 1} |T_{u_{j}}|\right) \) কমপ্লেক্সিটি লাগবে। \(x - a \leq \sum_{j = 1}^{i - 1} |T_{u_{j}}|\) এবং \(a \leq |T_{u_{i}}|\) কে একত্র করলে আমরা পাব \(x - \sum_{j = 1}^{i - 1} |T_{u_{j}}| \leq a \leq |T_{u_{i}}|\) অর্থাৎ, রিকারেন্সটিতে \(a\) এর রেঞ্জ \(1 \leq a \leq x\) কে পরিবর্তন করে \(x - \sum_{j = 1}^{i - 1} |T_{u_{j}}| \leq a \leq |T_{u_{i}}|\)  করে দিলেই হবে। এভাবে সবগুলো চাইল্ডের জন্য ক্যালকুলেট করতে \(\mathcal{O} \left ( \sum_{i = 1}^{m} \sum_{j = 1}^{i - 1} |T_{u_{i}}|.|T_{u_{j}}| \right ) \) কমপ্লেক্সিটি লাগবে। সুতরাং মোট কমপ্লেক্সিটি হবে

\[\mathcal{O} \left ( \sum_{i = 1}^{m} \sum_{j = 1}^{i - 1} |T_{u_{i}}|.|T_{u_{j}}| + \sum_{i = 1}^{m} |T_{u_{i}}|^{2} \right )\]
\[\leq \mathcal{O} \left ( 2 \sum_{i = 1}^{m} \sum_{j = 1}^{i - 1} |T_{u_{i}}|.|T_{u_{j}}| + \sum_{i = 1}^{m} |T_{u_{i}}|^{2} \right )\]
\[= \mathcal{O} \left ( \left ( \sum_{i = 1}^{m} |T_{u_{i}}| \right ) ^ {2} \right )\]
\[= \mathcal{O} \left ( |T_{v}| ^ {2} \right )\]

এখন \(T_{1}\) এর উপর এই এই উপপাদ্যটি প্রয়োগ করলেই প্রমাণ হয়ে যাবে সকল \(f_{*,*}\) এর মান \(\mathcal{O} (n^{2})\) কমপ্লেক্সিটিতে বের করা সম্ভব। 

\section{কম্বিনেটরিয়াল প্রমাণ}
একটি ভিন্ন সমস্যা নিয়ে চিন্তা করা যাক। ধর আমাদের বের করতে এমন কয়টি ক্রমজোড় \((x, y)\) আছে যেন নোড \(x\) এবং নোড \(y\) এর লোয়েস্ট কমন অ্যানসেসটর (lowest common ancestor) নোড \(v\) হয় এবং \(x\) ও \(y\) এর কোনটিই \(v\) এর সমান না হয়। একে আমরা \(F_{v}\) দ্বারা প্রকাশ করব। \(x\) আর \(y\) লোয়েস্ট কমন অ্যানসেসটর \(v\) হলে \(x\) এবং \(y\) অবশ্যই \(v\) এর দুটি ভিন্ন ভিন্ন চাইল্ডের সাবট্রিতে অবস্থিত। ধরা যাক \(x\) নোডটি \(T_{u_{i}}\) এবং \(y\) নোডটি \(T_{u_{j}}\) তে অবস্থিত। সুতরাং \((x, y)\) ক্রমজোড়টিকে মোট \(|T_{u_{i}}| \times |T_{u_{j}}|\) ভাবে বাছাই করা যেতে পারে। যদি আমরা সকল সম্ভাব্য চাইল্ডের ক্রমজোড় \((u_{i}, u_{j})\) (যাতে \(u_{i} \neq u_{j}\) হয়) এর জন্য \(|T_{u_{i}}| \times |T_{u_{j}}|\) এর যোগফল নির্নয় করি তাহলেই আমরা কাঙ্ক্ষিত উত্তর পেয়ে যাব। অর্থাৎ এমন ক্রমজোড় সংখ্যা হবে 

\[F_{v} = \sum |T_{u_{i}}|.|T_{u_{j}}| = 2 \sum_{i = 1}^{m} \sum_{j = 1}^{i - 1} |T_{u_{i}}| \times |T_{u_{j}}|\]

যেহেতু যেকোনো ক্রমজোড় \((x, y)\) এর জন্য একটি অনন্য লোয়েস্ট কমন অ্যানসেসটর আছে এবং সর্বমোট \(2 \binom{n}{2}\) টি \((x, y)\) ক্রমজোড় গঠন করা সম্ভব তাই আমরা লিখতে পারি 
\[\sum_{i = 1}^{n} F_{i} \leq 2 \binom{n}{2}\]

কিন্তু আমরা জানি \(\sum_{i = 1}^{m} \sum_{j = 1}^{i - 1} |T_{u_{i}}| \times |T_{u_{j}}|\) কমপ্লেক্সিটিতে আমরা কোনো নোড \(v\) এর জন্য \(f_{*,*}\) এর মানগুলো বের করতে পারি। অর্থাৎ \(f_{*,*}\) এর মানগুলো বের করতে আমাদের \(\mathcal{O} (F_{v})\) কমপ্লেক্সিটি প্রয়োজন। সুতরাং সকল নোডের জন্য \(f_{*,*}\) এর মান বের করলে আমাদের কমপ্লেক্সিটি হবে: 
\[\mathcal{O} \left ( \sum_{i = 1}^{n} F_{i} \right ) = \mathcal{O} \left ( 2 \binom{n}{2} \right )  =  \mathcal{O} \left ( n^{2} \right )\]

\section{অন্যান্য সমস্যা}
এই আইডিয়াটার সবচেয়ে ভালো দিক হচ্ছে এটি অন্যান্য অনেক ট্রি ডিপি সমস্যাতেই প্রয়োগ করা যায়। বিশেষত যদি ডিপি স্টেট-এ নোড ছাড়াও আরও একটি স্টেট থাকে তাহলে বেশির ভাগ ক্ষেত্রেই ব্যারিকেডস ট্রিক অ্যাপ্লিকেবল। নিজের করার জন্য কিছু অনুশীলন দেওয়া হল 

\begin{diybox}
\end{diybox}
