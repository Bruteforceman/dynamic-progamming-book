\chapter{কিছু ব্রুটফোর্স, ব্যাকট্র্যাকিং এবং বিটমাস্ক ট্রিকস}

সরাসরি ডাইনামিক প্রোগ্রামিং শুরু না করে আমরা যেকোনো কিছু ব্রুটফোর্স করে কিভাবে সমাধান করা যায় তা দেখা যাক। যেমন আমাদের কোন সমস্যায় মিনিমাম কস্ট বের করতে বলা হলে আমরা সবধরনের অ্যারেঞ্জমেন্ট ট্রাই করবো আর যেসব অ্যারেঞ্জমেন্ট প্রবলেমে দেওয়া শর্ত পূরণ করে সেগুলোর জন্য মিনিমাম কস্ট বের করে আমাদের ফাইনাল অ্যান্সার আপডেট করবো। এইধরনের চিন্তাধারা আমাদের সবচেয়ে বেশি কাজে লাগবে যেসব কাউন্টিং প্রবলেম ডিপি দিয়ে সল্ভ করতে হয় সেগুলো সল্ভ করার বেলায়। যদি তোমার আগে থেকে জানা না থাকে, তাহলে দেরি না করে এরকম কিছু ব্রুটফর্স টেকনিক দেখে নেয়াও যাক।

\section{একটুখানি বিট}
তোমাদের নিশ্চয়ই জানা আছে কম্পিউটার সবকিছু ০ আর ১ দিয়ে হিসাব করে। যেমন, \texttt{int} ডাটা টাইপে ৩২টা বিট স্টোর থাকে। যদিও, যেকোনো ম্যাথম্যাটিক্যাল অপারেটর (যেমন, যোগ, বিয়োগ, গুন, ভাগ ইত্যাদি) গুলোও বিটগুলো নিয়ে কাজ করে, এই অপারেটর গুলো ছাড়াও আরও কয়েকটি অপারেটর আছে যেগুলো ব্যবহার করে আমরা আমাদের ইমপ্লিমেন্টেশনকে অনেক সহজ আর সুন্দর করে ফেলতে পারি। সেগুলো দেখবো আমরা এখন।

\subsection{কম্পিউটার কিভাবে সংখ্যা স্টোর রাখে?}
\texttt{int} ডাটা টাইপে $59$ নাম্বারটি এইভাবে স্টোর থাকেঃ
\begin{center}
    \texttt{00000000000000000000000000111011}
\end{center}
শুরুর দিকে সব ০ থাকার কারণ হচ্ছে, যদিও ৫৯ কে বাইনারিতে প্রকাশ করতে আমাদের ঐ বিটগুলো দরকার হচ্ছে না, তারপরও যেহেতু \texttt{int} ডাটা টাইপ ৩২-বিটের, তাই ঐ বিট গুলোতে ০ সেভ রাখা হচ্ছে।

বিটগুলো নাম্বারিং করা হয় ডানপাশ থেকে বামপাশে। যেমন, কোন সংখ্যা $b$ এর $i$-তম বিটকে যদি আমরা $b_i$ দিয়ে প্রকাশ করি তাহলে সংখ্যাটিকে বাইনারিতে লেখা হবে এইভাবেঃ $\overline{b_{u-1} \ldots b_2 b_1 b_0}$, যেখানে $u$ হচ্ছে ডাটা টাইপের লেংথ। আর এই বাইনারিকে দশমিকে নিতে হলে আমরা এই ফরমুলা ব্যবহার করতে পারিঃ $b_{u-1} 2^{u-1} + \ldots + b_2 2^2 + b_1  2^1 + b_0 2^0$।

ডাটা টাইপ আবার দুইধরনের হতে পারে, Signed এবং Unsigned (যেমন, \texttt{int}, \texttt{unsigned int})। Signed ডাটা টাইপে ঋণাত্মক আর অঋণাত্মক সংখ্যা স্টোর রাখা এবং হিসাব নিকাশ করার জন্য 2's complement ব্যবহার করা হয়। একটা $u$ সাইজের signed ডাটা টাইপের ক্ষেত্রে যেকোনো সংখ্যা $x$ এর 2's Complement $x^{\prime}$ কে এমনভাবে ডিফাইন করা হয় যেন তা নিচের শর্ত পূরণ করেঃ $$x + x^\prime = 2^u$$। এই $x^\prime$ কেই কম্পিউটার $-x$ হিসেবে চিনে। এটা করে লাভ কি হলো? খেয়াল করো, $x + (-x)$ করার পরে কিন্তু কম্পিউটার যেটা পাচ্ছে তা হলো $2^u$ (অর্থাৎ, $u$-তম বিট অন শুধু, বাকি সব ০)। কিন্তু $u$ সাইজের একটা ডাটা টাইপ তো শুধু $u-1, u-2, \ldots, 2, 1, 0$ বিট গুলো স্টোর রাখতে পারে! তাহলে সে আসলে ঐ $u$-তম বিটটা ফেলে দিবে আর শেষপর্যন্ত সে যেটা সেভ রাখবে সেটার সব বিট অফ হবে -- অর্থাৎ শুন্য। তাই তো হওয়ার কথা! একটা সংখ্যার সাথে তার যোগাত্বক বিপরীত সংখ্যা যোগ করলে তও শুন্যই পাওয়ার কথা। তুমি যদি একটু চিন্তা করে দেখো, তাহলে দেখবে, দুটি সংখ্যা $x$ আর $y$ দিয়ে কম্পিউটারকে যদি বলা হয় $x-y$ হিসাব করতে, তাহলে সে কিন্তু $x$ এর সাথে $y^\prime$ যোগ করে দিয়েই বিয়োগফল বলে দিতে পারবে! আর বাইনারিতে যোগ করা তও সোজা।

\subsection{বিট অপারেশনসমূহ}

\subsubsection{And অপারেশন}
দুটো সংখ্যা $x$ আর $y$ এর and অপারেশন $x$ \& $y$ এমন একটা সংখ্যা বের করবে যেটার বাইনারিতে $i$-তম বিট অন থাকবে যদি ও কেবল যদি $x$ আর $y$ উভয়ের $i$-তম বিট অন থাকে। যেমন \texttt{207 \& 158 = 142}।
\begin{center}
\begin{tabular}{llr}
    & 11001111 & (207)\\
    \texttt{\&} & 10011110 & (158)\\
    \hline
    = & 10001110 & (142)
\end{tabular}
\end{center}

\subsubsection{Or অপারেশন}
দুটো সংখ্যা $x$ আর $y$ এর or অপারেশন $x$ \texttt{|} $y$ এমন একটা সংখ্যা বের করবে যেটার বাইনারিতে $i$-তম বিট অন থাকবে যদি ও কেবল যদি $x$ এবং $y$ এর অন্তত একটির $i$-তম বিট অন থাকে। যেমন \texttt{79 | 44 = 111}।
\begin{center}
\begin{tabular}{llr}
    & 01001111 & (79)\\
    \texttt{|} & 00101100 & (44)\\
    \hline
    = & 01101111 & (111)
\end{tabular}
\end{center}

\subsubsection{Xor অপারেশন}
দুটো সংখ্যা $x$ আর $y$ এর xor অপারেশন $x \caret y$ এমন একটা সংখ্যা বের করবে
যেটার বাইনারিতে $i$-তম বিট অন থাকবে যদি ও কেবল যদি $x$ এবং $y$ এর মধ্যে বরাবর
একটিতে $i$-তম বিট অন থাকে। যেমন \texttt{245 \caret\ 67 = 182}। Xor অপারেটরকে
ম্যাথেম্যাটিক্যালি অনেকসময় $\oplus$ দিয়েও লেখা হয়।
\begin{center}
\begin{tabular}{llr}
    & 11110101 & (245)\\
    \caret & 01000011 & (67)\\
    \hline
    = & 10110110 & (182)
\end{tabular}
\end{center}

\subsubsection{Not অপারেশন}
কোন সংখ্যা $x$ এর উপর Not অপারেশন ($\tilde x$) অ্যাপ্লাই করলে এমন একটা সংখ্যা পাওয়া যায় যার প্রত্যেকটা বিট $x$ এর উল্টা। যেমন, 16-bit ডাটা টাইপের জন্যঃ
\begin{center}
\begin{tabular}{rrrr}
$\tilde x$ & = & 14977 &   0011101010000001 \\
$\sim x$ & = & $-14978$ & 1100010101111110 \\
\end{tabular}
\end{center}
চিন্তা করে দেখো এই ফরমুলাটা কেন কাজ করেঃ $-x = \tilde x + 1$।

\subsubsection{বিট শিফট}

Todo.

\begin{lstlisting}[language=C++]
int ~someShit;
int y = a ^ b;
\end{lstlisting}


\begin{example}
    তোমাকে একটি $n$ সাইজের অঋণাত্মক সংখ্যার অ্যারে $a$ ($1 \le n \le 20, 0 \le a_i \le 10^9$) দেওয়া হয়েছে, তোমাকে বলতে হবে ঐ অ্যারে এর একটি উপাদান সর্বোচ্চ একবার নিয়ে কোন কোন যোগফল বানানো যায়।
\end{example}